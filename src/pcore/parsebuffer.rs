/// Basic parsing buffer manager, currently integrated with the
/// interface to parse primitive types.

use std::result::Result;
use std::error::Error;
use std::fmt;

#[derive(Debug)]
pub struct ParseBuffer {
    buf: Vec<u8>,
    ofs: usize,
}

#[derive(Debug, PartialEq, Eq)]
pub struct ParseError {
    msg: &'static str
}

impl ParseError {
    pub fn new(msg: &'static str) -> ParseError {
        ParseError{msg}
    }
}

// The trait defining the interface for parsing a primitive
// *fixed-size* type.
pub trait ParsleyPrim {
    // The Rust type for the parsed value
    type T;

    // The name of the type, used for logging/error-messages
    fn name() -> &'static str;

    // The fixed-size this type consumes from the parsing buffer.
    fn size_bytes() -> usize;

    // Parses a single fixed-size value from the provided buffer, and
    // returns the value and the number of bytes consumed from the
    // buffer.  There may not be size_bytes() in the buffer.
    fn parse(buf: &[u8]) -> Result<(Self::T,usize), ParseError>;
}

// TODO: this should be unified to the extent possible with
// ParsleyPrim. The main difference is that this type, unlike
// ParsleyPrim, does not consume a fixed size from the buffer.

pub trait ParsleyParser {
    // The Rust type for the parsed value
    type T;

    // The name of the type, used for logging/error-messages
    fn name() -> &'static str;

    fn parse(&mut self, buf: &mut ParseBuffer) -> Result<Self::T, ErrorKind>;
}

// Errors generated by this module.
#[derive(Debug, PartialEq, Eq)]
pub enum ErrorKind {
    // Insufficient data
    EndOfBuffer,
    // Errors during unguarded primitive parsing.
    PrimError(ParseError),
    // Errors during guarded primitive parsing.
    GuardError(&'static str),
}

impl fmt::Display for ErrorKind {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ErrorKind::EndOfBuffer => write!(f, "end of buffer"),
            ErrorKind::PrimError(ParseError{msg}) => write!(f, "primitive parse failure: {}", msg),
            ErrorKind::GuardError(prim) => write!(f, "primitive guard error on {}", prim),
        }
    }
}

impl Error for ErrorKind {
    fn description(&self) -> &str {
        match self {
            ErrorKind::EndOfBuffer => "end of buffer",
            ErrorKind::PrimError(ParseError{msg}) => msg,
            ErrorKind::GuardError(_prim) => "primitive guard error",
        }
    }
}

impl From<ParseError> for ErrorKind {
    fn from(err: ParseError) -> ErrorKind {
        ErrorKind::PrimError(err)
    }
}

impl ParseBuffer {
    pub fn new(buf: Vec<u8>) -> ParseBuffer {
        ParseBuffer { buf, ofs : 0 }
    }

    fn remaining(&self) -> usize {
        assert!(self.ofs <= self.buf.len());
        self.buf.len() - self.ofs
    }

    // Cursor management: get and set the parsing cursor; to allow
    // parsing to backtrack or rewind after an unsuccessful complex
    // parse.
    pub fn get_cursor(&self) -> usize {
        self.ofs
    }
    pub fn set_cursor(&mut self, ofs: usize) {
        assert!(ofs <= self.buf.len());
        self.ofs = ofs
    }

    // Parsing a single element of the Parsley primitive type P; it
    // returns a value of the Rust representation type P::T when successful.
    pub fn parse_prim<P : ParsleyPrim>(&mut self) ->
        Result<P::T, ErrorKind>
    {
        if self.remaining() < P::size_bytes() { return Err(ErrorKind::EndOfBuffer) }
        let (t, consumed) = P::parse(&self.buf[self.ofs..])?;
        assert_eq!(consumed, P::size_bytes());
        self.ofs += consumed;
        Ok(t)
    }

    // Parsing a single element of the Parsley primitive type P that
    // is constrained by a predicate 'guard'; it returns a value of
    // the Rust representation type P::T when successful.  The 'guard'
    // is specified in terms of the values of the representation type
    // P::T.
    pub fn parse_guarded<P : ParsleyPrim>(&mut self, mut guard: Box<FnMut(&P::T) -> bool>) ->
        Result<P::T, ErrorKind>
    {
        if self.remaining() < P::size_bytes() { return Err(ErrorKind::EndOfBuffer) }
        let (t, consumed) = P::parse(&self.buf[self.ofs..])?;
        assert_eq!(consumed, P::size_bytes());
        if !guard(&t) { return Err(ErrorKind::GuardError(P::name())) };
        self.ofs += consumed;
        Ok(t)
    }
}
