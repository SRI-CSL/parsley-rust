/// Basic parsing buffer manager, currently integrated with the
/// interface to parse primitive types.

use std::result::Result;
use std::error::Error;
use std::fmt;

#[derive(Debug)]
pub struct ParseBuffer {
    buf: Vec<u8>,
    valid: usize,
    ofs: usize,
}

#[derive(Debug)]
pub struct ParseError<'a> {
    msg: &'a str
}

impl<'a> ParseError<'a> {
    pub fn new(msg: &'a str) -> ParseError {
        ParseError{msg}
    }
}

// The trait defining the interface for parsing a primitive
// *fixed-size* type.
pub trait ParsleyPrim {
    // The Rust type for the parsed value
    type T;

    // The name of the primitive type, used for logging/error-messages.
    fn prim_name() -> &'static str;

    // The size of the primitive type.
    fn prim_size_bytes() -> usize;

    // Parses a single fixed-size value from the provided buffer, and
    // returns the value and the number of bytes consumed from the
    // buffer.  There will be at least prim_size_bytes() in the buffer.
    fn parse_one(buf: &[u8]) -> Result<(Self::T,usize), ParseError>;
}

// Errors generated by this module.
#[derive(Debug)]
pub enum ErrorKind<'a> {
    // Insufficient data
    EndOfBuffer,
    // Errors during unguarded primitive parsing.
    PrimError(ParseError<'a>),
    // Errors during guarded primitive parsing.
    GuardError(&'a str),
}

impl<'a> fmt::Display for ErrorKind<'a> {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            ErrorKind::EndOfBuffer => write!(f, "end of buffer"),
            ErrorKind::PrimError(ParseError{msg}) => write!(f, "primitive parse failure: {}", msg),
            ErrorKind::GuardError(prim) => write!(f, "primitive guard error on {}", prim),
        }
    }
}

impl<'a> Error for ErrorKind<'a> {
    fn description(&self) -> &str {
        match self {
            ErrorKind::EndOfBuffer => "end of buffer",
            ErrorKind::PrimError(ParseError{msg}) => msg,
            ErrorKind::GuardError(_prim) => "primitive guard error",
        }
    }
}

impl<'a> From<ParseError<'a>> for ErrorKind<'a> {
    fn from(err: ParseError) -> ErrorKind {
        ErrorKind::PrimError(err)
    }
}

// Parsing mode: either peek-ahead or consume.
#[derive(Debug,PartialEq,Eq)]
pub enum ParseMode {
    // Does not advance buffer cursor on success
    Peek,
    // Advances buffer cursor after a primitive parse
    Consume,
}

impl ParseBuffer {
    pub fn new(buf: Vec<u8>) -> ParseBuffer {
        ParseBuffer { buf, valid : 0, ofs : 0 }
    }

    fn remaining(&self) -> usize {
        assert!(self.valid >= self.ofs);
        self.valid - self.ofs
    }

    // Parsing a single element of the Parsley primitive type P; it
    // returns a value of the Rust representation type P::T when successful.
    pub fn parse_prim<P : ParsleyPrim>(&mut self, mode: ParseMode) ->
        Result<P::T, ErrorKind>
    {
        if self.remaining() < P::prim_size_bytes() { return Err(ErrorKind::EndOfBuffer) }
        let (t, consumed) = P::parse_one(&self.buf[self.ofs..])?;
        assert_eq!(consumed, P::prim_size_bytes());
        if mode == ParseMode::Consume { self.ofs += consumed; }
        Ok(t)
    }

    // Parsing a single element of the Parsley primitive type P that
    // is constrained by a predicate 'guard'; it returns a value of
    // the Rust representation type P::T when successful.  The 'guard'
    // is specified in terms of the values of the representation type
    // P::T.
    pub fn parse_guarded<P : ParsleyPrim>(&mut self, mode: ParseMode,
                                          mut guard: Box<FnMut(&P::T) -> bool>) ->
        Result<P::T, ErrorKind>
    {
        let (t, consumed) = P::parse_one(&self.buf[self.ofs..])?;
        assert_eq!(consumed, P::prim_size_bytes());
        if !guard(&t) { return Err(ErrorKind::GuardError(P::prim_name())) };
        if mode == ParseMode::Consume { self.ofs += consumed; }
        Ok(t)
    }
}
